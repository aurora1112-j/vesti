梳理一下针对 ChatGPT、Claude 两个平台的攻关路线图和知识体系。
MVP 范围确认：后端仅支持 ChatGPT + Claude；Gemini / DeepSeek 仅保留前端按钮，后端暂不接入。
新增：LLM 摘要/周报接入（ModelScope）
- 设置页配置（baseUrl / modelId / API Key）
- 协议扩展 + offscreen 调用
- Insights 页 UI 与缓存展示

探索性攻关路线图
阶段一：建立观察基础设施（1-2天）
第一步是建立一个"DOM 侦探系统"，让你能够快速理解每个平台的页面结构。在真正写 Parser 之前，你需要先"看见"这些平台是如何组织对话数据的。
具体做法：创建一个轻量级的 Content Script，它会在目标页面上注入一个调试面板。这个面板的核心功能是实时显示 DOM 树的变化。当 AI 开始回复时，你可以观察到哪些 DOM 节点在更新、它们的 class 名称是什么、数据属性（data-* attributes）包含哪些信息。
建议先在 ChatGPT 上验证这套基础设施，因为它的 DOM 结构相对稳定且文档较多。你可以手动在浏览器 DevTools 的 Console 中运行这段代码来快速探索：
javascript// 在目标页面的 Console 中运行，观察 DOM 变化
const observer = new MutationObserver((mutations) => {
  mutations.forEach((mutation) => {
    if (mutation.type === 'childList') {
      console.log('新增节点:', mutation.addedNodes);
      console.log('父容器:', mutation.target);
    }
  });
});

// 针对 ChatGPT，通常监听这个容器
const targetNode = document.querySelector('main') || document.body;
observer.observe(targetNode, { 
  childList: true, 
  subtree: true,
  characterData: true 
});
运行后开始一段对话，观察控制台输出，记录下消息容器的选择器规律。
阶段二：逐平台破解 DOM 结构（3-4天）
按照 ChatGPT → Claude 的顺序逐个攻克。这个顺序是有原因的：ChatGPT 作为最成熟的平台，网上有较多逆向经验可参考；Claude 的 DOM 与交互细节变化相对频繁，放在第二阶段更稳妥。
针对每个平台，你需要找到五个关键信息：
第一，对话容器的根选择器。这通常是包裹所有消息的最外层 div，在 React 应用中可能带有 id="__next" 或 id="root" 这样的标识。
第二，单条消息的节点特征。寻找能唯一标识一条消息的 DOM 特征，比如 data-message-id 属性，或者特定的 class 命名模式（如 .message-wrapper、.conversation-turn 等）。
第三，角色区分标记。如何判断一条消息是用户发送的还是 AI 回复的？可能是通过 data-author-role="user" 这样的属性，也可能是通过不同的 CSS class（如 .user-message vs .assistant-message）。
第四，内容提取路径。消息的文本内容存储在哪个子节点中？是直接的 textContent 还是需要处理 innerHTML？代码块是否有特殊的包裹结构（通常是 <pre><code> 组合）？
第五，会话元数据位置。对话标题在哪里？是否有唯一的 session ID 或 conversation ID 可以用于去重？这些信息通常藏在 URL 参数、页面标题元素或者某个隐藏的 data 属性中。
实用技巧：使用浏览器的"检查元素"功能时，右键点击某个消息，选择"复制 → 复制选择器"，可以快速获得该元素的 CSS 选择器路径。但要注意，自动生成的选择器往往过于具体（包含很多索引号），你需要手动简化成更通用的模式。
阶段三：实现 Parser 接口（2-3天）根据文档中定义的 IParser 接口，为 ChatGPT/Claude 创建独立的实现类。这里的核心思想是"选择器映射表"模式，将所有 DOM 查询逻辑集中管理。
以 ChatGPT 为例，你的 Parser 结构应该是这样的：
typescript// chatgpt-parser.ts
class ChatGPTParser implements IParser {
  // 选择器映射表 - 所有 DOM 查询都从这里来
  private readonly selectors = {
    conversationRoot: 'main [class*="react-scroll-to-bottom"]',
    messageList: '[data-testid^="conversation-turn-"]',
    userMessage: '[data-message-author-role="user"]',
    assistantMessage: '[data-message-author-role="assistant"]',
    messageContent: '.markdown',  // 可能需要调整
    title: 'nav h1',
    generatingIndicator: '.result-streaming',
    // 从 URL 或页面数据提取会话 ID
  };

  detect(): Platform | null {
    // 检测当前页面是否为 ChatGPT
    // 通常通过 URL 特征：chat.openai.com
    const isChatGPT = window.location.hostname.includes('chat.openai.com');
    return isChatGPT ? 'ChatGPT' : null;
  }

  getConversationTitle(): string {
    const titleElement = document.querySelector(this.selectors.title);
    return titleElement?.textContent?.trim() || 'Untitled Conversation';
  }

  getMessages(): ParsedMessage[] {
    // 核心逻辑：遍历所有消息节点，提取内容
    const messageNodes = document.querySelectorAll(this.selectors.messageList);
    return Array.from(messageNodes).map(node => this.parseMessageNode(node));
  }

  private parseMessageNode(node: Element): ParsedMessage {
    // 判断角色
    const isUser = node.querySelector(this.selectors.userMessage) !== null;
    
    // 提取文本（这里需要处理代码块、表格等特殊内容）
    const contentElement = node.querySelector(this.selectors.messageContent);
    const textContent = contentElement?.textContent || '';
    
    return {
      role: isUser ? 'user' : 'ai',
      textContent: textContent,
      htmlContent: contentElement?.innerHTML || '',  // MVP 可选
      timestamp: this.extractTimestamp(node),  // 如果 DOM 中有时间信息
    };
  }

  isGenerating(): boolean {
    // 检测是否正在生成
    return document.querySelector(this.selectors.generatingIndicator) !== null;
  }

  getSessionUUID(): string {
    // 从 URL 提取：chat.openai.com/c/{conversation-id}
    const match = window.location.pathname.match(/\/c\/([a-zA-Z0-9-]+)/);
    return match?.[1] || `fallback-${Date.now()}`;
  }
}
关键注意事项：不同平台的流式输出方式差异很大。ChatGPT 是逐 token 更新同一个 DOM 节点的 textContent，而有些平台（如早期的 Claude）是不断追加新的 <span> 元素。你的 Parser 需要能够处理这两种情况。
阶段四：集成 MutationObserver 和防抖逻辑（1天）
现在把 Observer 层和 Parser 层连接起来。根据文档，你需要实现一个 2000ms 的防抖机制，以避免在 AI 流式输出过程中触发过多的解析操作。
typescript// observer.ts
class ConversationObserver {
  private debounceTimer: ReturnType<typeof setTimeout> | null = null;
  private observer: MutationObserver | null = null;
  private parser: IParser;

  constructor(parser: IParser) {
    this.parser = parser;
  }

  start() {
    // 创建 MutationObserver
    this.observer = new MutationObserver(() => {
      // 每次 DOM 变化时重置计时器
      if (this.debounceTimer) {
        clearTimeout(this.debounceTimer);
      }

      // 如果 AI 正在生成，延长等待时间
      if (this.parser.isGenerating()) {
        this.debounceTimer = setTimeout(() => {
          this.triggerCapture();
        }, 2000);
      } else {
        // AI 已停止，立即触发（或短延迟）
        this.debounceTimer = setTimeout(() => {
          this.triggerCapture();
        }, 500);
      }
    });

    // 开始监听
    const targetNode = document.querySelector('main') || document.body;
    this.observer.observe(targetNode, {
      childList: true,
      subtree: true,
      characterData: true,
    });
  }

  private async triggerCapture() {
    console.log('🎯 触发捕获流程');
    
    // 调用 Parser 提取数据
    const messages = this.parser.getMessages();
    const title = this.parser.getConversationTitle();
    const uuid = this.parser.getSessionUUID();

    // 构建 Conversation 对象
    const conversation: Conversation = {
      uuid,
      platform: this.parser.detect()!,
      title,
      snippet: messages[0]?.textContent.slice(0, 100) || '',
      url: window.location.href,
      created_at: Date.now(),  // 首次捕获
      updated_at: Date.now(),
      message_count: messages.length,
      is_archived: false,
      is_trash: false,
      tags: [],
      stat_tokens: 0,  // MVP 阶段可以置 0
    };

    // 调用 Middleware Pipeline（下一阶段实现）
    await this.saveToDatabase(conversation, messages);
  }
}
防抖策略的数学表达：如果我们将 DOM 变化事件序列记为 {t1,t2,…,tn}\{t_1, t_2, \ldots, t_n\}
{t1​,t2​,…,tn​}，其中 tit_i
ti​ 表示第 ii
i 次变化的时间戳，那么捕获触发条件可以表示为：

Trigger  ⟺  (tcurrent−tlast_change>Δtthreshold)∧¬isGenerating()\text{Trigger} \iff (t_{\text{current}} - t_{\text{last\_change}} > \Delta t_{\text{threshold}}) \land \neg \text{isGenerating}()Trigger⟺(tcurrent​−tlast_change​>Δtthreshold​)∧¬isGenerating()
其中 Δtthreshold=2000ms\Delta t_{\text{threshold}} = 2000\text{ms}
Δtthreshold​=2000ms。这个公式的含义是：只有当距离上一次 DOM 变化超过阈值时间，且 AI 不在生成状态时，才触发捕获流程。

阶段五：数据库层和去重中间件（1-2天）
使用 Dexie.js 来管理 IndexedDB 操作。根据文档，你需要实现去重逻辑，避免重复存储同一会话。
typescript// middleware/deduplication.ts
async function deduplicateMiddleware(
  conversation: Conversation, 
  messages: ParsedMessage[]
): Promise<void> {
  // 检查数据库中是否已存在该 UUID
  const existing = await db.conversations
    .where('uuid')
    .equals(conversation.uuid)
    .first();

  if (existing) {
    // 已存在 - 执行增量更新
    console.log('📝 检测到已存在会话，执行增量更新');
    
    // 只有消息数量增加时才更新
    if (conversation.message_count > existing.message_count) {
      await db.conversations.update(existing.id!, {
        updated_at: Date.now(),
        message_count: conversation.message_count,
        snippet: conversation.snippet,  // 更新预览
      });

      // 计算新增消息：比较数量差异
      const newMessageCount = conversation.message_count - existing.message_count;
      const newMessages = messages.slice(-newMessageCount);

      // 写入新消息
      await db.messages.bulkAdd(
        newMessages.map(msg => ({
          conversation_id: existing.id!,
          role: msg.role,
          content_text: msg.textContent,
          content_html: msg.htmlContent || '',
          content_markdown: '',  // MVP 阶段可以留空
          created_at: msg.timestamp || Date.now(),
        }))
      );
    }
  } else {
    // 新会话 - 完整写入
    console.log('✨ 新会话，创建记录');
    
    const conversationId = await db.conversations.add(conversation);

    await db.messages.bulkAdd(
      messages.map(msg => ({
        conversation_id: conversationId,
        role: msg.role,
        content_text: msg.textContent,
        content_html: msg.htmlContent || '',
        content_markdown: '',
        created_at: msg.timestamp || Date.now(),
      }))
    );
  }
}
```

**增量更新的关键**：这里使用消息数量（`message_count`）作为简单的"版本号"。如果发现远程（当前页面）的消息数大于本地（数据库）的消息数，说明有新内容，只需要提取末尾的差异部分写入。这种方式的时间复杂度是 $O(k)$，其中 $k$ 是新增消息数，而不是 $O(n)$（$n$ 为总消息数）。

## 知识与术语地图

让我为你构建一个概念体系，这些都是你在开发过程中会频繁遇到的术语：

### 浏览器扩展架构层

**Content Script（内容脚本）**：这是运行在宿主页面上下文中的 JavaScript 代码，可以访问和修改页面的 DOM，但与页面原生脚本隔离（不共享变量作用域）。你的所有 Observer 和 Parser 逻辑都运行在这里。

**Background Service Worker（后台服务工作进程）**：Manifest V3 中替代原有 Background Page 的概念，是一个事件驱动的脚本，负责处理扩展的生命周期事件、管理跨页面的状态同步等。在你的架构中，它主要负责协调不同 Content Script 之间的数据通信。

**Shadow DOM（影子 DOM）**：一种 Web 标准，允许你创建一个封装的 DOM 子树，其内部的样式和脚本不会受外部影响，反之亦然。文档中提到的"胶囊悬浮条"必须用 Shadow DOM 包裹，就是为了防止 ChatGPT 自身的 CSS 样式污染你的 UI 组件。

**Manifest V3**：Chrome 扩展的最新规范版本，相比 V2 引入了更严格的权限模型和性能要求。Plasmo 框架会自动帮你处理 V3 的配置细节。

### DOM 操作与监听层

**MutationObserver API**：浏览器提供的原生 API，用于监听 DOM 树的变化（节点增删、属性修改、文本内容变化等）。相比旧的 `DOMSubtreeModified` 事件，MutationObserver 是异步批量触发的，性能更好。

**防抖（Debouncing）**：一种常用的性能优化技术。在高频事件（如 DOM 变化、窗口 resize）中，通过延迟执行来减少函数调用次数。具体机制是：如果在等待期间再次触发事件，就重置计时器。可以用状态机表示：
```
状态转移：IDLE --[事件]→ WAITING --[Δt 超时]→ EXECUTE --→ IDLE
                       ↑______________|
                      [新事件：重置定时器]
CSS Selector（CSS 选择器）：用于定位 DOM 元素的查询语言。你的 Parser 依赖于准确的选择器来找到消息节点。常见模式包括类选择器（.class-name）、属性选择器（[data-id="123"]）、伪类（:first-child）等。
数据持久化层
IndexedDB：浏览器内置的 NoSQL 数据库，支持存储结构化数据和大容量文件。相比 LocalStorage（上限 5-10MB），IndexedDB 的配额可达数 GB，适合你存储大量对话记录。
Dexie.js：IndexedDB 的上层封装库，提供了类似 Promise 的异步 API 和更简洁的查询语法。原生 IndexedDB 的 API 非常冗长（需要手动管理事务、游标等），Dexie 大大降低了使用门槛。
复合索引（Compound Index）：在数据库中对多个字段建立的联合索引，可以加速特定的组合查询。文档中的 [platform+created_at] 就是一个复合索引，允许你高效地查询"某个平台在某个时间范围内的所有会话"。查询复杂度从 O(n)O(n)
O(n) 降到 O(log⁡n+k)O(\log n + k)
O(logn+k)，其中 kk
k 是结果集大小。

架构设计模式层
策略模式（Strategy Pattern）：定义一系列算法（Parser），让它们可以互相替换。你的 IParser 接口就是策略模式的体现，不同平台的 Parser 是不同的策略实现，但对外提供统一的接口。
中间件模式（Middleware Pattern）：将一个复杂流程拆解为多个独立的处理单元（中间件），按顺序执行，每个中间件可以修改数据或决定是否继续传递。你的去重、降噪逻辑就是两个中间件，数据依次流经它们。可以用函数组合表示：
Output=Mn∘Mn−1∘⋯∘M1(Input)\text{Output} = M_n \circ M_{n-1} \circ \cdots \circ M_1(\text{Input})Output=Mn​∘Mn−1​∘⋯∘M1​(Input)
Local-First 架构：一种设计理念，强调所有数据处理和存储优先在本地完成，服务器（如果有）仅作为可选的同步层。这种架构的优势是隐私保护、离线可用、零延迟响应。
调试与验证层
Console Logging（控制台日志）：开发阶段最重要的调试手段。建议在关键节点（Observer 触发、Parser 提取、数据库写入）都加上带 emoji 的日志标记（如 🎯、📝、✨），方便在大量日志中快速定位。
React DevTools：如果宿主页面（如 ChatGPT）是用 React 构建的，你可以用 React DevTools 查看组件树和 Props，这有助于理解数据流向和找到消息节点的 React 组件名称。
Breakpoint Debugging（断点调试）：在 Chrome DevTools 的 Sources 面板中，你可以直接在 Content Script 代码上打断点。结合 debugger; 语句，可以暂停执行并检查变量状态。
探索性验证建议
在正式开发之前，我建议你先做几个快速验证实验，每个实验控制在 30 分钟以内：
实验一：最小 MutationObserver
在 ChatGPT 页面的 Console 中直接运行一个最简单的 Observer，开始一段对话，观察触发频率。调整 debounce 时间，找到最佳阈值（文档建议 2000ms，但不同平台可能需要微调）。
实验二：选择器稳定性测试
找到某个消息的选择器后，刷新页面、新建会话、切换不同模型（GPT-4 vs GPT-3.5），检查这个选择器是否仍然有效。如果某些选择器包含动态生成的 ID（如 message-id-xyz123），说明需要改用更通用的模式（如属性选择器 [data-message-id]）。
实验三：Dexie 读写性能
创建一个包含 1000 条模拟会话记录的测试数据集，测试查询和写入的响应时间。IndexedDB 的性能在不同浏览器中差异较大，提前测试可以避免后期的性能瓶颈。
实验四：跨平台 UUID 提取
在 ChatGPT、Claude 两个平台上，手动查看 URL 结构和页面元素，找出各自的会话 ID 存储位置。有些平台可能没有显式的 URL 参数，需要从 LocalStorage 或页面的 <script> 标签中提取。Gemini/DeepSeek 先保留前端按钮，后端解析暂缓。
